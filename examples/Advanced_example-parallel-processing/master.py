#!/usr/bin/env python
#SBATCH --job-name=UCLA_workflow-MOLNAME
#SBATCH --output=out-%A
#SBATCH --error=error-%A
#SBATCH --partition=short,lopez
#SBATCH --nodes=1
#SBATCH --cpus-per-task=9
#SBATCH --mem=20G
#SBATCH --time=1-00:00:00

solvent = 'acetonitrile'
dftmethod = 'B3LYP/6-311G(d,p) empiricaldispersion=gd3bj'
preopt_method = 'B3LYP/6-31G(d,p) empiricaldispersion=gd3bj'
tddftmethod = 'wb97xd/6-31G(d,p)'
nproc = 24
mem = 120
time = '1-00:00:00'
mpnproc = 9
partition = 'short,lopez'

###################################################################

from workflowV2 import molecule
from rdkit.Chem import AllChem
from workflowV2.calculator import RunBatch
from workflowV2.software.GAUSSIAN import GAUSSIAN
from workflowV2 import message
import pandas as pd
import sys
import os
import numpy as np
from datetime import datetime
from argparse import ArgumentParser
import multiprocessing as mp

#import supporting scripts here
#need to add to python path...
sys.path.insert(0,'/home/neal.pa')
print(sys.path)
from UCLA_workflow.util import open_csv,unlock_csv,look_for_restart,par_proc
from UCLA_workflow.excitation_flow import excitation_flow
from UCLA_workflow.S1_reactant_flow import S1_reactant_flow
from UCLA_workflow.reduction_flow import reduction_flow
from UCLA_workflow.oxidation_flow import oxidation_flow

###################################################################

def setup(smiles,mol_name='my_mol',nconfs=10,dummy='[*:1][Y]',
          substituents=['[*:1][H]','[*:1]OC','[*:1]OC(F)(F)F','[*:1]C','[*:1]C(F)(F)F','[*:1][N+](=O)[O-]','[*:1]F','[*:1]Cl','[*:1]C#N'],
          names=['H','OMe','OCF3','Me','CF3','NO2','F','Cl','CN'],
          charge=0,
          mult=1):

    '''Get things prepared before jumping into workflow'''
    global mol_names, mols, output_energies

    #log the output to a file
    message.logtofile('{0}.log'.format(mol_name))

    #write energies to file
    output_energies = '{0}-output_energies.csv'.format(mol_name)

    #first construct the names for each substituted molecule
    mol_names = [mol_name + '_' + name for name in names]

    #check if there is a checkpointed mol for the first one
    mols = False

    if os.path.exists(mol_names[0] + '.chk'):
        mols = [molecule.ReadCheckpoint(mol + '.chk') for mol in mol_names]
        message.log('''##################################################################\nfound checkpoined mols for restart at step {1} - {0}\n##################################################################

    '''.format(datetime.now(),mols[0].tags['step']),time=False)

    #if not found, we need to modify the input smiles, and create a molecule object for each
    #molecule that we generate

    #I could use the 'replace substructs' to do this more efficiently
    # but I'd rather keep the flexibility of the reaction smarts
    else:
        message.log('''##################################################################\nStarting workflow at - {0}\n##################################################################

    '''.format(datetime.now()),time=False)

        mol = AllChem.MolFromSmiles(smiles)
        rxns = [AllChem.ReactionFromSmarts(f'{dummy} >> {substituent}') for substituent in substituents]
       
        smiles = []
        for rxn in rxns: 
            current = mol
            new = [[current]]  #nested list to mimic what RDkit will return later
            prods = 1
            #while the product of the rxn keeps changing
            #keep applying the rxn        
            while prods > 0:
                current = new[0][0]
                new = rxn.RunReactants((current,))
                prods = len(new)

            smiles.append(AllChem.MolToSmiles(current))

        #Create the mol objects with nconformers generated by UFF, start with high rmsd to get as
        #diverse structures as possible, at the expense of waiting to slowly reduce the threshold
        mols = [molecule.SmilesToMol(smile,nconfs=nconfs,pruneRmsThresh=1.0,tags={'step':0},charge=charge,mult=mult) for smile in smiles]

##################################################################

##################################################################

##################################################################


def PM7(args):
    mol,name = args
    return(mol.RefineConformers(GAUSSIAN,runtype='opt',jobname=name+'-PM7',
                                              method='PM7',
                                              nproc=nproc,
                                              mem=mem,
                                              time=time,
                                              partition=partition,
                                              tries=3,ignore=True,inplace=False))

##################################################################

def SP(args):
    mol,name = args
    return(mol.RefineConformers(GAUSSIAN,runtype='sp',jobname=name+'-SP',
                                              method=dftmethod ,scrf=f'iefpcm,solvent={solvent}',
                                              nproc=nproc,
                                              mem=mem,
                                              time=time,
                                              partition=partition,inplace=False))


#################################################################

#################################################################

#################################################################

 
def main(smiles,mol_name,nconfs,dummy,substituents,names,charge=0,mult=0,no_reduction=False,no_oxidation=False):

    '''6 part workflow:

           0. Generate conformers with RDkit
           1. Refine conformers with PM7
           2. Use DFT SP to choose lowest conf
           3. Neutral preoptimization 
           4. Neutral optimization                     
           5. Split into four processes to run in parallel, each starting with the reactant S0 geometry:
               5.1. excitation_flow
                    5.1.1. TDDFT SP for photophysics
               5.2. S1_reactant_flow
                    5.2.1. reactant S1 optimization
               5.3. oxidation_flow
                    5.3.1. oxidation preoptimization for guess geometry
                    5.3.2. processes split, each starting from guess
                        5.3.1. ground state oxidation
                        5.3.2. excited state oxidation
               5.4. reduction_flow
                    5.4.1. reduction preoptimization for guess geometry
                    5.4.2. processes split, each starting from guess
                        5.4.1. ground state reduction
                        5.4.2. excited state reduction
   '''

   #get some variables set up before going through the flow
    global mol_names,mols,output_energies,solvent,dftmethod,tddftmethod,nproc,mem,time,mpnproc,partition
    setup(smiles,mol_name,nconfs,dummy,substituents,names,charge,mult)

    ##################################################################

    if mols[0].tags['step'] < 1:

        os.makedirs('PM7',exist_ok=True)
        os.chdir('PM7')

        pool = mp.Pool(mpnproc)
        args = [(mol,name) for mol,name in zip(mols,mol_names)]
        mols = pool.map(PM7,args)
        pool.close()
        pool.join()

        for mol,name in zip(mols,mol_names):
            mol.checkpoint('{0}-PM7.mol'.format(name))

        os.chdir('../')

        for mol,name in zip(mols,mol_names):
            mol.tags['step'] = 1
            mol.checkpoint('{0}.chk'.format(name))

    ##################################################################

    if mols[0].tags['step'] < 2:

        os.makedirs('SP',exist_ok=True)
        os.chdir('SP')

        pool = mp.Pool(mpnproc)
        args = [(mol,name) for mol,name in zip(mols,mol_names)]
        mols = pool.map(SP,args)
        pool.close()
        pool.join()

        for mol,name in zip(mols,mol_names):
            mol.checkpoint('{0}-SP.mol'.format(name))

        os.chdir('../')

        for mol,name in zip(mols,mol_names):
            mol.tags['step'] = 2
            mol.checkpoint('{0}.chk'.format(name))

    ##################################################################

    if mols[0].tags['step'] < 3:
   
        #take the lowest energy conformer
        mols = [mol.conformers[0] for mol in mols]

        os.makedirs('S0-reactant-preopt',exist_ok=True)
        os.chdir('S0-reactant-preopt')

        calculators = [GAUSSIAN(mol,runtype='opt',jobname=name+'-S0-reactant-preopt',
                                    method=preopt_method,scrf=f'iefpcm,solvent={solvent}',
                                    opt='MaxCycles=15',
                                    nproc=nproc,
                                    mem=mem,
                                    time=time,
                                    partition=partition) for index,mol,name in zip(range(len(mols)),mols,mol_names)]

        mols = RunBatch(calculators,tries=1,jobname=f'{mol_name}-S0-reactant-preopts',ignore=True)

        for mol,name in zip(mols,mol_names):
            mol.checkpoint('{0}-reactant-preopt.mol'.format(name))

        os.chdir('../')

        for mol,name in zip(mols,mol_names):
            mol.tags['step'] = 3
            mol.checkpoint('{0}.chk'.format(name))

    ##################################################################

    if mols[0].tags['step'] < 4:
   
        os.makedirs('S0-reactant',exist_ok=True)
        os.chdir('S0-reactant')

        oldchk,geom,guess = look_for_restart(mol_names,'S0-reactant')
        calculators = [GAUSSIAN(mol,runtype='opt_freq',jobname=name+'-S0-reactant',
                                    method=dftmethod,scrf=f'iefpcm,solvent={solvent}',
                                    opt='recalcfc=10',
                                    nproc=nproc,
                                    mem=mem,
                                    time=time,
                                    oldchk=oldchk[index],
                                    geom=geom[index],
                                    guess=guess[index],
                                    partition=partition) for index,mol,name in zip(range(len(mols)),mols,mol_names)]

        mols = RunBatch(calculators,tries=3,jobname=f'{mol_name}-S0-reactants')

        for mol,name in zip(mols,mol_names):
            mol.checkpoint('{0}-reactants.mol'.format(name))

        os.chdir('../')

        df = pd.DataFrame([[name,mol.energy,mol.properties['homo'] * 27.211,mol.properties['lumo'] * 27.211] for mol,name in zip(mols,mol_names)],columns=['Molecule','S0_reactant_free_energy','HOMO (eV)','LUMO (eV)'])
        df.to_csv(output_energies,index=False)

        for mol,name in zip(mols,mol_names):
            mol.tags['step'] = 4
            mol.checkpoint('{0}.chk'.format(name))

    ##################################################################

    #THIS IS WHERE WE CAN FORK THE PROCESSES 

    if mols[0].tags['step'] < 5:


        if no_reduction and no_oxidation:

            task_list = [
                      {'func':excitation_flow,'tasks':[{'mols':mols,'mol_names':mol_names,'output_energies':output_energies,
                                                        'solvent':solvent,'dftmethod':dftmethod,'tddftmethod':tddftmethod,
                                                        'nproc':nproc,'mem':mem,'time':time,'partition':partition,'mol_name':mol_name}]},
                    ]

        elif no_reduction:

             task_list = [
                      {'func':excitation_flow,'tasks':[{'mols':mols,'mol_names':mol_names,'output_energies':output_energies,
                                                        'solvent':solvent,'dftmethod':dftmethod,'tddftmethod':tddftmethod,
                                                        'nproc':nproc,'mem':mem,'time':time,'partition':partition,'mol_name':mol_name}]},

                      {'func':S1_reactant_flow,'tasks':[{'mols':mols,'mol_names':mol_names,'output_energies':output_energies,
                                                        'solvent':solvent,'dftmethod':dftmethod,'tddftmethod':tddftmethod,'mol_name':mol_name,
                                                        'nproc':nproc,'mem':mem,'time':time,'partition':partition,'preopt_method':preopt_method}]},
                      {'func':oxidation_flow,'tasks':[{'mols':mols,'mol_names':mol_names,'output_energies':output_energies,
                                                        'solvent':solvent,'dftmethod':dftmethod,'tddftmethod':tddftmethod,'mol_name':mol_name,
                                                        'nproc':nproc,'mem':mem,'time':time,'partition':partition,'preopt_method':preopt_method}]},
                    ]

        elif no_oxidation:
   
             task_list = [
                      {'func':excitation_flow,'tasks':[{'mols':mols,'mol_names':mol_names,'output_energies':output_energies,
                                                        'solvent':solvent,'dftmethod':dftmethod,'tddftmethod':tddftmethod,
                                                        'nproc':nproc,'mem':mem,'time':time,'partition':partition,'mol_name':mol_name}]},

                      {'func':S1_reactant_flow,'tasks':[{'mols':mols,'mol_names':mol_names,'output_energies':output_energies,
                                                        'solvent':solvent,'dftmethod':dftmethod,'tddftmethod':tddftmethod,'mol_name':mol_name,
                                                        'nproc':nproc,'mem':mem,'time':time,'partition':partition,'preopt_method':preopt_method}]},
                      {'func':reduction_flow,'tasks':[{'mols':mols,'mol_names':mol_names,'output_energies':output_energies,
                                                        'solvent':solvent,'dftmethod':dftmethod,'tddftmethod':tddftmethod,'mol_name':mol_name,
                                                        'nproc':nproc,'mem':mem,'time':time,'partition':partition,'preopt_method':preopt_method}]},
                    ]

        else:

            task_list = [
                      {'func':excitation_flow,'tasks':[{'mols':mols,'mol_names':mol_names,'output_energies':output_energies,
                                                        'solvent':solvent,'dftmethod':dftmethod,'tddftmethod':tddftmethod,
                                                        'nproc':nproc,'mem':mem,'time':time,'partition':partition,'mol_name':mol_name}]},

                      {'func':S1_reactant_flow,'tasks':[{'mols':mols,'mol_names':mol_names,'output_energies':output_energies,
                                                        'solvent':solvent,'dftmethod':dftmethod,'tddftmethod':tddftmethod,'mol_name':mol_name,
                                                        'nproc':nproc,'mem':mem,'time':time,'partition':partition,'preopt_method':preopt_method}]},
                      {'func':oxidation_flow,'tasks':[{'mols':mols,'mol_names':mol_names,'output_energies':output_energies,
                                                        'solvent':solvent,'dftmethod':dftmethod,'tddftmethod':tddftmethod,'mol_name':mol_name,
                                                        'nproc':nproc,'mem':mem,'time':time,'partition':partition,'preopt_method':preopt_method}]},
                      {'func':reduction_flow,'tasks':[{'mols':mols,'mol_names':mol_names,'output_energies':output_energies,
                                                        'solvent':solvent,'dftmethod':dftmethod,'tddftmethod':tddftmethod,'mol_name':mol_name,
                                                        'nproc':nproc,'mem':mem,'time':time,'partition':partition,'preopt_method':preopt_method}]},
                    ]

        if len(task_list) < mpnproc:
            ncpu = len(task_list)
        else:
            ncpu = mpnproc
        
        results = par_proc(task_list,num_cpus=ncpu)
        failed_branches = []
        for result in results:
            for func,status in result.items():
                if status != 'complete':
                    failed_branches.append(func)

        if len(failed_branches) > 0:
            message.warning(f'Failed calculations in the {failed_branches} sub-processes!!! ... exiting')
            raise ValueError('sub-process did not return complete')

        for mol,name in zip(mols,mol_names):
            mol.tags['step'] = 5
            mol.checkpoint('{0}.chk'.format(name))
   
##################################################################

##################################################################

##################################################################

if __name__ == '__main__':

    #parse arguments
    parser = ArgumentParser('UCLA organic photosensitizer workflow',fromfile_prefix_chars='@')
    parser.add_argument('-s','--smiles',type=str,dest='smiles')
    parser.add_argument('--mol_name',type=str,dest='mol_name',default='my_mol')
    parser.add_argument('--substituents',dest='substituents',type=str,nargs='+',default=['[*:1][H]','[*:1]OC','[*:1]OC(F)(F)F','[*:1]C','[*:1]C(F)(F)F','[*:1][N+](=O)[O-]','[*:1]F','[*:1]Cl','[*:1]C#N'])
    parser.add_argument('--names',dest='names',type=str,nargs='+',default=['H','OMe','OCF3','Me','CF3','NO2','F','Cl','CN'])
    parser.add_argument('--dummy',dest='dummy',type=str,default='[*:1][Y]')
    parser.add_argument('--nconfs',dest='nconfs',type=int,default=10)
    parser.add_argument('-q','--charge',dest='charge',type=int,default=0)
    parser.add_argument('-m','--mult',dest='mult',type=int,default=1)
    parser.add_argument('--no_reduction',dest='no_reduction',action='store_true',default=False)
    parser.add_argument('--no_oxidation',dest='no_oxidation',action='store_true',default=False)
    arguments = parser.parse_args()

    if len(arguments.names) != len(arguments.substituents):
        raise IndexError('There must be equal number of substituents and names')

    main(arguments.smiles,arguments.mol_name,
         arguments.nconfs,
         arguments.dummy,
         arguments.substituents,
         arguments.names,
         arguments.charge,
         arguments.mult,
         arguments.no_reduction,
         arguments.no_oxidation)

    message.log('Done!')
